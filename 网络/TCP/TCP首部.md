#TCP首部

TCP是面向字节流的，但是TCP传送的数据却是报文段。一个TCP报文段分为首部和数据两部分。

![image-20191002105618711](https://tva1.sinaimg.cn/large/006y8mN6gy1g7jo5hshvij312i0bsdiw.jpg)



##源端口和目的端口

记录了源端口号（Src Port），目标端口号（Dst Port），各占2字节。

TCP 的报文里是没有源 ip 和目标 ip 的，因为那是 IP 层协议的事情，TCP 层只有源端口和目标端口。

源 IP、源端口、目标 IP、目标端口唯一标识一个TCP连接。



有了IP协议，数据包可以顺利被传输到IP地址对应的主机。但是主机收到这个数据包的时候，应该把数据包提交给哪一个应用程序进行处理呢？

传输层就是使用端口号同一个机器上不同应用程序的。操作系统为进程分配端口号，当主机收到数据包后，查询数据包首部的端口号字段，然后将数据发送到对应端口的进程。

![image-20191002160901064](https://tva1.sinaimg.cn/large/006y8mN6gy1g7jx6v3srzj312u0iaahn.jpg)

主动发起的客户端进程也需要开启端口，会把自己的端口放在首部的源端口（source port）字段中，以便对方知道要把数据回复给谁。



### 端口号分类

端口号被划分成以下 3 种类型：

- 熟知端口号（well-known port）
- 已登记的端口（registered port）
- 临时端口号（ephemeral port）



#### 熟知端口号

熟知端口号由专门的机构由 IANA 分配和控制，范围为 0~1023。为了能让客户端能随时找到自己，服务端程序的端口必须要是固定的。很多熟知端口号已经被用就分配给了特定的应用，比如 HTTP 使用 80端口，HTTPS 使用 443 端口，ssh 使用 22 端口。 访问百度`http://www.baidu.com/`，其实就是向百度服务器之一（163.177.151.110）的 80 端口发起请求

在 Linux 上，如果你想监听这些端口需要 Root 权限，为的就是这些熟知端口不被普通的用户进程占用，防止某些普通用户实现恶意程序（比如伪造 ssh 监听 22 端口）来获取敏感信息。熟知端口也被称为保留端口。



####已登记的端口

已登记的端口不受 IANA 控制，不过由 IANA 登记并提供它们的使用情况清单。它的范围为 1024～49151。

为什么是 49151 这样一个魔数？ 其实是取的端口号最大值 65536 的 3/4 减 1 （49151 = 65536 * 0.75 - 1）。可以看到已登记的端口占用了大约 75% 端口号的范围。

已登记的端口常见的端口号有：

- MySQL：3306
- Redis：6379
- MongoDB：27017



####临时端口号

如果应用程序没有调用 bind() 函数将 socket 绑定到特定的端口上，那么 TCP 和 UDP 会为该 socket 分配一个唯一的临时端口。IANA 将 49152～65535 范围的端口称为临时端口（ephemeral port）或动态端口（dynamic port），也称为私有端口（private port），这些端口可供本地应用程序临时分配端口使用。

不同的操作系统实现会选择不同的范围分配临时端口，在 Linux 上能分配的端口范围由 /proc/sys/net/ipv4/ip_local_port_range 变量决定，一般 Linux 内核端口范围为 32768~60999

```
cat /proc/sys/net/ipv4/ip_local_port_range                                      
32768 	60999
```

在需要主动发起大量连接的服务器上（比如网络爬虫、正向代理）可以调整 ip_local_port_range 的值，允许更多的可用端口。













##序列号

共4字节。TCP连接中传送的字节流中的每一个字节都按顺序编号。序列号（Sequence Number）指的是本报文段的第一个字节的序列号。

![image-20191002122029963](https://tva1.sinaimg.cn/large/006y8mN6gy1g7jql2yyppj314e0amjwf.jpg)

序列号加上报文长度，就可以确认传输的是哪一段数据。序列号是一个32位的无符号整数，达到2^32-1后循环到0。

在SYN报文中，序列号用于交换彼此的起始序列号。在其他报文中，序列号用于保证包的顺序。

因为网络层不保证包的顺序，TCP使用序列号来解决乱序、重复的问题，以保证数据包以正确的顺序组装传递给应用层。

如果发送方发送的是四个报文序列号分别是1、2、3、4，但到达接收方的顺序是 2、4、3、1，接收方就可以通过序列号的大小顺序组装出原始的数据。



## 初始序列号

这只是一个概念，不是某个字段。

在连接建立之初，通信双方都会各自确定一个序列号，称为初始序列号（Initial Sequence Number， ISN）。

在建立连接时，通信双方通过SYN报文交换彼此的ISN。

值得注意的是，**并不存在初始序列号这个字段**，只是我们的叫法而已。我的理解是请求数据包中SYN=1，表明这个数据包的SEQ是初始序列号。而ACK数据包中SYN+ACK表明这个SEQ是服务端的初始序列号。

![image-20191002122940772](https://tva1.sinaimg.cn/large/006y8mN6gy1g7jqumpvv2j30z20ooqdc.jpg)

其中第 2 步和第 3 步可以合并一起，这就是三次握手的过程：

![image-20191002123031017](https://tva1.sinaimg.cn/large/006y8mN6gy1g7jqvij2hdj30uu0ngn4n.jpg)

初始序列号并非从0开始，通信双方各自生成。一般情况下，两端生成的序列号不会相同。

生成的算法是：ISN随时间而变化，会递增的分配给后续TCP连接的ISN。



**ISN 能设置成一个固定值吗？**

答案是不能。

1、出于安全性考虑。

如果被知道了连接的ISN，很容易构造一个在对方窗口内的序列号，源 IP 和源端口号都很容易伪造，这样一来就可以伪造 RST 包，将连接强制关闭掉了。如果采用动态增长的 ISN，要想构造一个在对方窗口内的序列号难度就大很多了。

2、避免前后连接互相干扰

因为开启 SO_REUSEADDR 以后端口允许重用，收到一个包以后不知道新连接的还是旧连接的包，因为网络的原因姗姗来迟，造成数据的混淆。如果采用动态增长的 ISN，那么可以保证两个连接的 ISN 不会相同，不会串包。









##确认号

TCP使用确认号（ACK）来告知对方下一个期望接收到的序列号，小于此序列号的所有字节都已经收到了。

![image-20191002124649040](https://tva1.sinaimg.cn/large/006y8mN6gy1g7jrch5fq1j313m0gmdkk.jpg)

关于确认号有几个注意点：

- 不是所有包都需要确认的（比如说ACK包就不需要确认，否则就会进入确认的死循环）
- 不是收到数据包就立马需要确认，可以延迟一会再确认
- 确认号永远表示小于此确认号的所有字节都已经收到了
- TCP无法选择确认，只能对初始序列号到连续收到字节的最后一个序号做确认，无法做部分确认。







## TCP Flags

TCP Flags是一个标记字段，共8位，大部分情况用到后6位。这些标记可以用来同步初始序列号，可以用来确认数据包，可以用来结束连接等。

![image-20191002125203978](https://tva1.sinaimg.cn/large/006y8mN6gy1g7jrhx9h21j310y0bagpv.jpg)

我们通常所说的SYN、ACK、FIN、RST其实只是把Flags对应bit置为1而已。这些标记可以组合使用，比如SYN+ACK，FIN + ACK等。



### 常见的Flags

- SYN：用于发起连接数据包，同步双方的初始序列号
- ACK：用于确认数据包
- RST：这个标记用来强制断开连接，通常是之前建立的连接已经不存在了、包不合法。
- FIN：通知对方我发完了所有数据，准备断开连接，后面我不会再发数据包给你了
- PSH：告知对方接收到这些数据包以后，立马提交给上层应用，而不能缓存起来。





##窗口大小

窗口大小用于告诉对方，从本报文段首部的确认号算起，接收方目前**允许对方发送的数据量**。

- 之所以有此限制，是因为接收方的数据缓存空间是有限的。
- 由于接收缓存不断变化，因此窗口值也不断变化。



![image-20191002130357417](https://tva1.sinaimg.cn/large/006y8mN6gy1g7jruaq5wyj31280b4adi.jpg)

可以看到用于表示窗口大小的"Window Size" 只有 16 位，可能但是 TCP 协议设计者们认为 16 位的窗口大小以及够用了，也就是最大窗口大小是 65535 字节（64KB）。就像网传盖茨曾经说过：“640K内存对于任何人来说都足够了”一样。

自己挖的坑当然要自己填，因此TCP 协议引入了「TCP 窗口缩放」选项 作为窗口缩放的比例因子，比例因子值的范围是 0 ~ 14，其中最小值 0 表示不缩放，最大值 14。比例因子可以将窗口扩大到原来的 2 的 n 次方，比如窗口大小缩放前为 1050，缩放因子为 7，则真正的窗口大小为 1050 * 128 = 134400。

窗口缩放值在3次握手的时候（请求方、接收方分别发送SYN的时候）指定。





##选项

![image-20191002130733716](https://tva1.sinaimg.cn/large/006y8mN6gy1g7jry1vktej310q0as77l.jpg)

可选项的格式入下所示

![image-20191002130753348](https://tva1.sinaimg.cn/large/006y8mN6gy1g7jrye22v7j311c03ctac.jpg)

以MSS为例：

![image-20191002130829491](https://tva1.sinaimg.cn/large/006y8mN6gy1g7jrz0lvx0j31300bygr6.jpg)



### 常用选项

#### MSS（最大段大小选项）

用于指出允许接收的最大报文段的**长度**。

当MSS非常小时，网络利用率非常低。如果MSS非常大，在IP层传送时，就可能要分片，到终点后再将各个分片组装成原来的TCP报文段，这也会使开销增大。因此，MSS可以尽量大，只要在IP层传输时不分片就行了。

```
MSS = MTU - IP header头大小 - TCP 头大小
```

TCP 为了避免被发送方分片，会主动把数据分割成小段再交给网络层，最大的分段大小称之为 MSS（Max Segment Size）。这样一个 MSS 的数据恰好能装进一个 MTU 而不用分片。

举个例子：在以太网中 TCP 的 MSS = 1500（MTU） - 20（IP 头大小） - 20（TCP 头大小）= 1460

![image-20191002155327872](https://tva1.sinaimg.cn/large/006y8mN6gy1g7jwqoai8nj311q0c678z.jpg)

MSS选项只出现在SYN报文中。

一般来说，如果没有分段发生，MSS还是越大越好。报文段越大，允许报文段传输的数据越多，从而提高网络利用率。

当TCP发送一个SYN时，或者是因为一个本地进程想发起一个连接，或者是另一端的主机收到了链接请求。它能将MSS设置为外出接口的MTU减去固定的IP首部和TCP首部长度。

真正发送数据的长度由对端的MSS和本机的外出接口MTU决定，取两者最小值。比如说对端MSS是1500，而外出接口MTU是296，那么本机发送数据最大还是296。从而避免分段。



**TCP 报文的最大载荷**

指去掉TCP头部、IP头部的数据实体的大小。





#### 窗口缩放选项

窗口缩放选项（Window Scale）是为了扩大窗口。使TCP的窗口可以从16bit增加到32bit。

这个选项只能出现在SYN报文中，为了使窗口扩大，两端必须在它们的SYN报文段中发送这个选项。主动连接的一方在其SYN报文中发送这个选项，但是被动连接的一方只能在接受到这个选项的SYN报文时，才可以发送含有这个选项的报文段。



####时间戳选项

发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确计算出RTT。

- 计算往返时延RTT：

  当a主机接收到b主机发送过来的确认ack报文s2时，a主机此时内核时刻为ta2.

  a主机从s2报文的timestamp echo选项中可以解析出该确认ack确认的报文的发送时刻为ta1.

  那么：RTT＝接收ack报文的时刻－发送报文的时刻＝ta2 －ta1.

  ta2和ta1都来自a主机的内核，所以不需要在tcp连接的两端进行任何时钟同步的操作。

- 防止回绕的序号：

  我们知道TCP报文的序列号只有32位，而每增加2^32个序列号后就会重复使用原来用过的序列号。假设我们有一条高速网络，通信的主机双方有足够大的带宽涌来快速的传输数据。例如1Gb/s的速率发送报文，则不到35秒报文的序号就会重复。这样对TCP传输带来混乱的情况。而采用时间戳选项，可以很容易的分辨出相同序列号的数据报，哪个是最近发送，哪个是以前发送的。



####SACK

SACK选择确认选项。

**接收方能告诉发送方哪些报文段已经收到了**。

根据这些信息，发送方就可以只重传哪些真正丢失的报文段。

需要注意的是只有收到失序的分组时才会可能会发送SACK。

TCP的ACK还是建立在累积确认的基础上的。也就是说如果收到的报文段与期望收到的报文段的序号相同就会发送累积的ACK，**SACK只是针对失序到达的报文段的**。

SACK包括了两个TCP选项，一个选项用于标识是否支持SACK，是在TCP连接建立时时发送；另一种选项则包含了具体的SACK信息。





- 数据偏移：它指出了TCP报文段的数据部分的起始处 距离 **TCP报文段起始处**有多远。这个字段实际上指出了TCP的首部。由于首部中有长度不确定的选项字段，因此数据偏移是必要的。
- 保留6位：保留为以后使用。都是0
- 紧急URG：当此处为1时，标明紧急指针字段有效。它告诉系统此报文段有紧急数据，需要尽快传送。系统会把紧急数据插入到TCP缓存的前面。它和紧急指针配合使用。 
- 确认ACK：当ACK=1时，确认号(ack)字段才有效。当ACK=0时，确认好无效。当连接建立前ACK=0，建立之后ACK就一直是1了。
- 推送PSH：当PSH=1时，系统会立刻将此报文段发送出去，而不再等待整个缓存都被填满后才发送。
- 复位RST：当其为1时，标明TCP出现严重错误，必须释放连接然后再重新连接。
- 同步SYN：用于建立连接。
  - 当同步SYN为1而ACK为0时，表明这是一个建立连接请求
  - 当SYN=1，ACK=1，表示这是一个建立连接之后的响应
- 终止FIN：用来释放连接。当其为1时，表明此报文段的发送方的数据已经发送完毕，要求释放连接。
- 检验和：用于检查在传输过程中。TCP报文是否被改动。如果接收方检测到检验和有差错，则TCP段会被直接丢弃。
- 紧急指针：只有**紧急URG=1**才有意义。由于紧急数据放在了缓冲区的最前方，紧急指针指出的是紧急数据的末尾在报文段的位置。当所有的紧急数据都处理完了以后，TCP就告诉程序恢复正常操作。