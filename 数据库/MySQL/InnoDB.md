# InnoDB



## 体系架构

![image-20190804160338041](http://ww2.sinaimg.cn/large/006tNc79gy1g5nph2nbprj312a0owdkl.jpg)

InnoDB存储引擎架构由 内存池 + 后台线程组成。

**内存池**：

- 维护所有进程/线程需要访问的多个内部数据结构
- 缓存磁盘上的数据，方便快速的访问，同时在对磁盘文件进行修改之前，在这里缓存。
- 重做日志（rodo log）缓冲


**后台线程**

主要作用是：

- 刷新内存池中的数据，保证缓冲池中的数据是最新的数据。
- 将已修改的数据文件刷新到磁盘文件。
- 保证在数据库发生异常的情况下，InnoDB能恢复到正常运行状态



## 后台线程

InnoDB是多线程模型，其后台有多个不同的后台线程，负责处理不同的任务



### Master Thread

master thread是一个非常核心的后台线程，**负责将缓冲池中的数据异步刷新到磁盘**，保证数据的一致性。包括脏页的刷新、合并插入缓冲、undo页的回收。



### IO Thread

InnoDB中大量使用AIO（阻塞IO）处理写IO请求。可以极大提升数据库的性能。而io thread的主要工作是负责这些**io请求的回调处理**。



### Purge Thread

事务被提交后，其所使用的undo log可能不再需要，因此需要Purge Thread来**回收已经使用并且分配的undo页。**  此线程的目的也是为了减轻Master线程的负担。



### Page Cleaner Thread

在InnoDB1.2中引入的线程，用于把脏页的刷新操作放到单独的线程中处理，从而减轻Master线程的负担。





## 内存

### 缓冲池

InnoDB是基于磁盘存储的，并且把记录按照页的方式进行管理。

缓冲池简单来说就是一块内存区域，通过内存的速度磁盘速度较慢对数据库性能的影响。在数据库中读取页的操作，首先将从磁盘中读取的页放到缓冲池中，下一次再读相同的页时，首先判断该页是否在缓冲池中，若命中，直接读取该页。否则，读取磁盘上面的页。

**对于数据库中页的修改操作，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。**注意，页从缓冲池刷新到磁盘的操作并不是在每次页发生变更的时候触发，而是通过一种Checkpoint的机制刷新回磁盘，同样是为了提高数据库性能。

缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。如下图：

![image-20190804163242792](http://ww2.sinaimg.cn/large/006tNc79gy1g5nqbbq8d4j312w0hqjwj.jpg)

LRU列表用来管理已经读取的页，但当数据库刚启动的时候，LRU列表是空的，即没有任何页。这时页都存放在Free列表中。当需要从缓冲池中获取一页内存，存放磁盘数据时，首先从Free列表中查找是否有可用的空闲页，若有，则将该列表从Free列表中删除，放入到LRU列表中。否则，根据LRU算法，淘汰LRU列表末尾的页，将该内存分配给新的页。

在缓存中的页（LRU列表中的页）被修改后，称该页为**脏页**，即缓冲池中的页和磁盘上的页的数据产生了不一致。 这时数据库会通过checkpoint机制将脏页刷新到磁盘。而Flush列表中的页即为脏页。



### 重做日志缓存

InnoDB首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。

重做日志在下列三种情况会将重做日志缓中的内容刷新到磁盘的重做日志文件中：

（1）Master Thread每一秒将重做日志缓冲刷新到重做日志文件

（2）事务提交时，将重做日志缓冲刷新到重做日志文件

（3）当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件



### 额外的内存池

在对一些数据结构本身的内存进行分配的时候，需要从额外的内存池中进行申请。



## Checkpoint技术

**Checkpoint（检查点）技术**为了解决如下几个问题：

（1）缩短数据库的恢复时间：

​			当数据库宕机时，数据库不需要重做所有的日志，因为Checkpoint之前的页已经刷新都磁盘，因此数据库只要对Checkpoint之后的重做日志进行恢复。这样大大缩小了恢复时间。

（2）缓冲池不够用时，将脏页刷新到磁盘

​			当缓冲池不够用时，LRU算法会算法最近最少使用的页，若此页是脏页，那么需要强制执行checkpoint，将脏页（页的最新版本）刷回到磁盘

（3）重做日志不可用时，刷新脏页

​			![image-20190804181144982](http://ww2.sinaimg.cn/large/006tNc79gy1g5nt6dccv0j31ce0ay47j.jpg)





## 关键特性



### 插入缓存

插入缓存是用于提高插入记录的效率。它既是缓冲池的一部分，也存在与物理页中。

在 InnoDB 存储引擎中，主键是行唯一的标识符。通常应用程序中行记录的插入顺序是按照主键递增的顺序进行插人的。因此，插入聚集索引（ Primary Key ）一般是顺序的，不需要磁盘的随机读取。比如按下列 SQL 定义表：

```java
CREATE TABLE t ( 
   a INT AUTO INCREMENT ,
   b VARCHAR(30) , 
   PRIMARY KEY ( a ) 
);
```

其中 a 列是自增长的，若对 a 列插人 NULL 值，则由于其具有 AUTO INCREMENT 属性，其值会自动增长。

同时页中的行记录按 a 的值进行顺序存放。在一般情况下，不需要随机读取另一个页中的记录，直接在最后一条记录后面插入新的记录即可。因此，对于这类情况下的插人操作，速度是非常快的。

注意并不是所有的主键插入都是顺序的。若主键类是 UUID 这样的类，那么插入和辅助索引一样，同样是随机的。即使主键是自增类型，但是插入的是指定的值，而不是 NULL 值，那么同样可能导致插入并非连续的情况。

一张表上可能有多个非聚集的辅助索引（ secondary index ）。比如，用户需要按照 b 这个字段进行查找，并且 b 这个字段不是唯一的，即表是按如下的 SQL 语句定义的：

```mysql
CREATE TABLE t (
 a INT AUTO INCREMENT , 
 b VARCHAR ( 30 ) , 
 PRIMARY KEY ( a ) , 
 key ( b ) 
);
```

在这样的情况下产生了一个非聚集的且不是唯一的索引。在进行插人操作时，数据页的存放还是按主键 a 进行顺序存放的，但是对于非聚集索引叶子节点的插入不再是顺序的了，这时就需要离散地访问非聚集索引页（遍历找到可以插入索引页），由于随机读取的存在而导致了插人操作性能下降。

当然这并不是这个 b 字段上索引的错误，而是因为 B+树的特性决定了非聚集索引插入的离散性。

InnoDB 存储引擎开创性地设计了 Insert Buffer 。

- 对于非聚集索引的插人或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插人；
- **若不在，则先放入到一个 Insert Buffer 中，好似欺骗，数据库这个非聚集索引已经插到叶子节点，而实际并没有，只是存放在插入缓存中**。然后再以一定的频率和情况进行 Insert Buffer 和非聚集索引页子节点的 merge（合并）操作，这时通常能将多个插人合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插人的性能。



 Insert Buffer 的使用需要同时满足以下两个条件：

- 索引是辅助索引（ secondary index ) ;
- 索引不是唯一（ unique ）的
  - 因为非聚集索引放到插入缓存的时候，数据库并不去查找索引页来判断插入的记录的唯一性。如果去查找，肯定又会有离散读的发生，从而导致插入缓存失去意义。













## 与MyISAM区别

- InnoDB支持**事务**、**外键**，MyISAM不支持
- InnoDB**支持行锁**，MyISAM**只支持表锁**
- InnoDB是**聚集索引**。而MyISAM是非聚集索引

- InnoDB不保存表的具体行数（执行select count(*) from table时需要全表扫描）。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；
  - InnoDB 5.7中对select count(*)的优化： http://www.bcty365.com/content-35-5679-1.html





## InnoDB缓存



### LRU

最近最少使用算法（LRU）是大部分操作系统为最大化页面命中率而广泛采用的一种页面置换算法。该算法的思路是，发生缺页中断时，选择未使用时间最长的页面置换出去。



操作系统，会有**缓冲池**(buffer pool)机制，避免每次访问磁盘，以加速数据的访问。

MySQL作为一个存储系统，同样具有**缓冲池**(buffer pool)机制，以避免每次查询数据都进行磁盘IO。



**InnoDB的缓冲池缓存什么？**

缓存表数据和索引数据



**作用**

把磁盘上的数据加载到**缓冲池**，避免每次访问都产生磁盘IO，起到加速访问的作用。



**为啥不把所有数据都放到缓冲池里**？

因为缓存造价昂贵，存储容量小。因此需要把热数据放到缓冲池中，以最大限度降低磁盘访问。



**什么是预读？**

磁盘读写，并不是按需读取，而是按页读取，一次至少读一页数据（一般是4k），如果未来要读取的数据就在页中，就能从页中直接读取数据，从而省去磁盘IO，提高效率



**预读为什么能有效减少磁盘IO？**

数据访问，通常遵循“局部性原理”（使用一些数据，大概率会使用附近的数据）。“局部性原理”表明提现加载的确是有效的，确实能够减少磁盘IO，因此预读是有效的。



**按页(4K)读取，和InnoDB的缓冲池设计有啥关系？**

（1）磁盘按页读取能够提高性能，所以缓冲池一般也是按页读取（缓冲池中页的大小默认为16KB，也就是说缓冲池一次读取一页数据，相当于读取4页磁盘数据）

（2）按页读取，会使用预读，从而减少未来的磁盘IO



**InnoDB是以什么算法，来管理这些缓冲页呢？**

LRU



**传统的LRU是如何进行缓冲页管理？**

最常见的LRU实现方法：把进入缓冲池的页放入链表头部，作为最近访问的元素，从而最晚被淘汰。这里又分为2种情况：

（1）页已经在缓冲池里面，则把页移动到链表头部

（2）页不在缓冲池中，则从磁盘读取所需要的页，并且放到链表头部。然后把链表末尾的页淘汰掉。

![image-20190803183423353](http://ww1.sinaimg.cn/large/006tNc79gy1g5mo7mhapzj30wg0kktdr.jpg)

![image-20190803183447159](http://ww2.sinaimg.cn/large/006tNc79gy1g5mo81pjd3j30u00boq5w.jpg)





### InnoDB版本的LRU

**传统的LRU缓冲池算法十分直观**，OS，memcache等很多软件都在用，MySQL为什么不直接使用呢？主要是两个原因：

（1）预读失效

（2）缓冲池污染



**什么是预读失效？**

由于预读，提前把页放入到缓冲池，但最终MySQL并没有从该页中读取数据，称为“预读失效”。



**如何对预读失效进行优化？**

要优化预读失效，思路是：

（1）让预读失败的页，尽早从缓冲池中淘汰

（2）让真正被读取的页，尽量在缓冲池中留久一些

具体做法是：

（1）将LRU分为两部分：新生代 和 老年代

（2）新生代首尾相连，即新生代的尾（tail）连接老年代的头（head）

（3）新页加入缓冲池，只加入老年代的头部：

​		a、如果数据被访问，才会加入新生代头部

​		b、如果数据没有被访问，则会比新生代的“热数据页”更早被淘汰出缓冲池

![image-20190803185358586](http://ww1.sinaimg.cn/large/006tNc79gy1g5mos045lqj30ok0i8n0z.jpg)

![image-20190803185433201](http://ww1.sinaimg.cn/large/006tNc79gy1g5moslq4bkj311w0e2tdc.jpg)

![image-20190803185506718](http://ww1.sinaimg.cn/large/006tNc79gy1g5mot6bl76j30rq0f2n0z.jpg)



新老生代改进版LRU仍然解决不了缓冲池污染的问题。



**什么是MySQL缓冲池污染？**

当某一个SQL语句，要扫描大量数据时，可能导致把缓冲池上的所有页都替换出去，导致大量热数据被换出，MySQL性能急剧下降，这种情况缓存池污染

例如，有一个数据量较大的用户表，当执行：

select * from user where name like "%shenjian%";

虽然结果集可能只有少量数据，但这类like不能命中索引，必须全表扫描，就需要访问大量的页：

（1）把页加到缓冲池（插入老生代头部）；

（2）从页里读出相关的row（插入新生代头部）；

（3）row里的name字段和字符串shenjian进行比较，如果符合条件，加入到结果集中；

（4）…直到扫描完所有页中的所有row…

如此一来，所有的数据页都会被加载到新生代的头部，但只会访问一次，真正的热数据被大量换出。



**怎么解决这类扫描大量数据导致的缓冲池污染问题呢？**

MySQL加入了一个“老年代停留时间窗口”参数

（1）假设T=老年代停留时间窗口

（2）插入老年代的页，即时被访问，也不会立即放入新生代的头部

（3）只有满足**被访问** 并且 **在老年代停留时间大于T**，才会被放入新生代

![image-20190803193350125](http://ww3.sinaimg.cn/large/006tNc79gy1g5mpxh3gnqj30y20u0490.jpg)

![image-20190803193416421](http://ww4.sinaimg.cn/large/006tNc79gy1g5mpxxma9ij31440te7i2.jpg)



**上述原理，对应InnoDB里哪些参数？**

innodb_buffer_pool_size：配置缓冲池的大小，在内存允许的情况下，DBA往往会建议调大这个参数，越多数据和索引放到内存里，数据库的性能会越好。



innodb_old_blocks_pct：老年代占整个LRU链表长度的比例，默认是37，即整个链表中新生代和老年代的比例是63 ： 37。     *如果把这个参数设为100，就退化为普通LRU了。*



innodb_old_blocks_time：老年代停留时间窗口，单位是毫秒。默认是1000。



**总结**

（1）缓冲池(buffer pool)是一种**常见的降低磁盘访问的机制；**

（2）缓冲池通常**以页(page)为单位缓存数据；**

（3）缓冲池的**常见管理算法是LRU**，memcache，OS，InnoDB都使用了这种算法；

（4）InnoDB对普通LRU进行了优化：

- 将缓冲池分为**老生代和新生代**，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，以解决预读失效的问题
- 页被访问，且在老生代**停留时间超过配置阈值**的，才进入新生代，以解决MySQL缓冲池污染的问题





## 扩展

**外键**：如果没有为外键显示添加索引，InnoDB自动为外键创建索引，这样子避免表锁。

**行级锁**：InnoDB行级锁基于索引实现。