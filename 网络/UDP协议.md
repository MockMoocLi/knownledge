# UDP



## 概述

UDP是简单的，面向数据报的运输层协议。进程的每个输出操作都正好生成一个UDP数据，并组装成一个IP数据报。

![image-20200706191345789](https://tva1.sinaimg.cn/large/007S8ZIlgy1gghgssqp64j30bw05kglw.jpg)

UDP不提供可靠性：它将应用程序传给IP层的数据发送出去，但是不保证它们可以到达目的地。









## UDP 首部格式

![image-20200706191624761](https://tva1.sinaimg.cn/large/007S8ZIlgy1gghgvi9dm5j30hn071wf2.jpg)

首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

端口号表示发送进程和接收进程。由于IP层已经把IP数据报分配给TCP或UDP（根据IP首部中协议字段值），因此TCP端口号由TCP来查看，而UDP端口号由UDP来查看。**TCP端口号与UDP端口号是相互独立的。**UDP和TCP端口是程序自己定义的，而不是某个固定的端口。
UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为 8字节。这个UDP长度是有冗余的。IP数据报长度指的是数据报全长，因此UDP数据报长度是全长减去IP首部的长度。





## UDP分片举例

![image-20200817230103632](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu7e95sg8j31180js0vi.jpg)



## MTU路径发现机制

**MTU指的是数据链路层的数据报最大传输单元。**

**路径MTU指的是在传输路径中的MTU的最小值。** 就是无需进行分片处理就能穿过这条“路径”的最大传输单元。

当路由器收到一个IP数据报，数据报长度大于当前网络的MTU，但是该数据报又设置了不可分片，因此会返回给发送端一个ICMP不可到达差错报文。在报文中会告诉发送端下一站网络的MTU。

![image-20200817230514766](https://tva1.sinaimg.cn/large/007S8ZIlgy1ghu7ijxob3j31a40h4q73.jpg)



**如何查找路径MTU？**

 发送端发送一个比较大的分组，并且设置DF（不可分片）为1，如果返回ICMP不可分片差错报文，就发送一个较小的分组，直到发送端没有返回ICMP不可分片差错报文，那么这个分组的大小就可以认为是路径MTU。  

可以利用利用traceroute确定路径MTU。要做的就是发送分组，并且设置DF。发送的第一个分组的长度正好与出口MTU相等。每次收到ICMP不能分片差错时，就减少分组的长度。如果路由器返回的ICMP差错报文是新的格式，包含出口MTU，那么就用该MTU值来发送。否则就用下一个最小的MTU值来发送。（MTU值的个数是有限的，在程序中有一些MTU值构成的表，取表中的下一个MTU值作为分组长度，来发送分组）



**路径MTU发现**

指的是系统自动设置分组的DF不可分片标志位，来查找路径MTU。

但是这样子可能到导致正常发送的数据报被丢弃。因此，应该关闭这个机制。





## UDP服务器的设计



### 端口和IP

客户端的UDP数据报，IP首部包含源端和目的端的IP地址，UDP首部包含源端和目的端的端口号。当一个应用接收到UDP数据报时，操作系统必须告诉它是谁发送了这份消息，即源IP地址和源端口号。这个特性允许一个UDP服务对多个客户端的请求进行应答。

一些应用程序需要知道数据报是发送给谁的，所以需要目的IP地址。



### UDP输入队列

大多UDP服务器是交互式服务器，即单个服务器进程对单个端口上的所有客户端请求进行处理。

通常程序所使用的每个UDP端口都与一个有限大小的输入队列相联系。这意味着来自不同客户端的差不多同时到达的请求将会在队列中排队。接收到UDP数据报以其接收顺序交给应用程序。

如果请求太多了，超过了队列的长度，内核会直接丢弃超出的UDP数据报，那么应用就有可能丢失UDP数据报。



## 参考

[UDP概述](https://blog.csdn.net/china_jeffery/article/details/78923428)

[TCP/IP卷一](http://www.52im.net/topic-tcpipvol1.html)

[TCP/IP学习笔记](https://blog.csdn.net/lh470342237/article/details/76599052?locationNum=10&fps=1)

