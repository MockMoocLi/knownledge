# 四次挥手

最常见的四次挥手的过程下图所示

![image-20191002182649556](https://tva1.sinaimg.cn/large/006y8mN6gy1g7k168u2noj30ys0lkn7g.jpg)



##第一次挥手

客户端调用close方法，执行**主动关闭**，会发送一个FIN报文给服务端，这以后客户端不能再发送数据给服务端了。客户端进入**FIN-WAIT-1**状态。FIN报文其实就是把FIN字段置为1。

FIN报文段是可以携带数据的，比如客户端可以在它最后要发送的数据里面“捎带”FIN端。当然也可以不携带数据，不携带数据的话，需要消耗一个序列号。

客户端发送FIN报文之后，还可以继续接受服务端的数据，这也就是所谓的半关闭。

- 《TCP/IP详解》的解释为：TCP提供了连接的一端结束它的发送以后，还能接收另外一端的数据的能力
- 为了使用这个特性，编程接口必须为应用程序提供一种方式来说明：我已经完成了数据的发送，因此发送一个FIN给另一端，但我还想接收另一端发来的数据，直到它发来FIN。
- 为什么要有半关闭呢？
  - 举个例子，客户端想让专门的排序服务器对数据进行排序，那么客户端在传递完数据给服务器以后，发送一个FIN报文，告诉服务器发送完毕了，服务器进行排序，然后把结果返回给客户端，并且发送FIN报文给客户端，这个连接正常结束。
  - 如果没有半关闭，客户端在传输完数据以后，还要其他技术来通知服务器数据传输完毕了，但仍然要接收服务器的数据。

主动发起关闭的一方称为主动关闭方；被动发起关闭的一方称为被动关闭方。



## 第二次挥手

服务端收到FIN包以后回复确认ACK，服务端进入CLOSE-WAIT状态，客户端收到确认ACK后进入FIN-WAIT-2状态。



## 第三次挥手

服务端也没有数据发送了，发送FIN报文给客户端，然后进入LAST-ACK状态，等待客户端的ACK。同前面一样如果 FIN 段没有携带数据，也需要消耗一个序列号。



## 第四次挥手

客户端收到服务端的FIN报文后，回复ACK，进入TIME_WAIT状态，等待2个MSL以后，进入CLOSE状态。

服务端收到ACK以后，进入CLOSE状态。





**为什么 FIN 报文要消耗一个序列号**

![image-20191002190622197](https://tva1.sinaimg.cn/large/006y8mN6gy1g7k2bdxa02j30vy0o0n4r.jpg)

如上图所示，如果 FIN 包不消耗一个序列号。客户端发送了 100 字节的数据包和 FIN 包，都等待服务端确认。如果这个时候客户端收到了ACK=1000 的确认包，就无法得知到底是 100 字节的确认包还是 FIN 包的确认包。







## 同时关闭

前面介绍的都是一端收到了对端的 FIN，然后回复 ACK，随后发送自己的 FIN，等待对端的 ACK。TCP 是全双工的，当然可以两端同时发起 FIN 包。如下图所示

![image-20191002191218152](https://tva1.sinaimg.cn/large/006y8mN6gy1g7k2hkjarlj30xa0s0akt.jpg)

以客户端为例（上图貌似有问题）

- 最初客户端和服务端都处于 ESTABLISHED 状态
- 客户端发送 `FIN` 包，等待对端对这个 FIN 包的 ACK，随后进入 `FIN-WAIT-1` 状态
- 处于`FIN-WAIT-1`状态的客户端还没有等到 ACK，收到了服务端发过来的 FIN 包
- 收到 FIN 包以后客户端会发送对这个 FIN 包的的确认 ACK 包，同时自己进入 `CLOSING` 状态
- 继续等自己 FIN 包的 ACK
- 处于 `CLOSING` 状态的客户端终于等到了ACK，随后进入`TIME-WAIT`
- 在`TIME-WAIT`状态持续 2*MSL，进入`CLOSED`状态





## 问题

**为什么挥手要四次，变为三次可以吗？**

首先我们先明确一个问题，TCP 连接终止一定要四次包交互吗？三次可以吗？

当然可以，因为有**延迟确认**的存在，把第二步的 ACK 经常会跟随第三步的 FIN 包一起捎带会对端。延迟确认后面有一节专门介绍。

![image-20191002190741603](https://tva1.sinaimg.cn/large/006y8mN6gy1g7k2crl87zj30yy0m0n3i.jpg)



如果不及时发送 ACK 包，客户端死等服务端这边发送数据，可能会造成客户端不必要的重发 FIN 包，如下图所示。

![image-20191002190930200](https://tva1.sinaimg.cn/large/006y8mN6gy1g7k2enr5syj30ha0rkn1p.jpg)

如果服务端确定没有什么数据需要发给客户端，那么当然是可以把 FIN 和 ACK 合并成一个包，四次挥手的过程就成了三次。



**为什么TCP建立连接是3次握手，而关闭连接要4次握手**

建立一个连接需要3次握手，而终止一个连接需要4次握手。这由TCP的半关闭造成的。既然一个连接是全双工的（即数据在两个方向上都能传递），因此每个方向必须单独的进行关闭。这原则就是当一方完成它的数据发送任务后，就发送FIN来终止这个方向的连接。当一段收到FIN，就会通知应用层对端已经终止发送数据。

收到一个FIN只意味着这个方向上面没有数据流动。一个TCP连接收到一个FIN后仍然能够发送数据。对于应用半关闭的程序来说，这种情况是可能的。