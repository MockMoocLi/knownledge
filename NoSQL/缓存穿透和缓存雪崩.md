# 缓存穿透和缓存雪崩



## 缓存穿透



### 概念

缓存穿透是指从缓存中没有查到数据，而直接从数据库中查询数据的情况。

![image-20191109110015926](https://tva1.sinaimg.cn/large/006y8mN6gy1g8rltbf2zkj30g00im0w3.jpg)



### 解决方案

- 先把数据库所有的元素key放入到布隆过滤器中。
- 当发生请求的时候，先去布隆过滤器判断该元素key是否存在(bd.exists指令)
- 如果布隆过滤器中没有，则说明元素不存在
- 如果布隆过滤器中有，则去redis缓存中查询该数据
- 如果redis缓存不存在，则去数据库查询数据

![image-20191109115222630](https://tva1.sinaimg.cn/large/006y8mN6gy1g8rnbj6pppj30k40majxa.jpg)



这样子肯定也有缺点：

- 使用了布隆过滤器，肯定就要去维护它。
  - 比如说数据库新增了主键key，就要到布隆过滤器中新增该key
  - 如果数据库删除了某些数据，就要到布隆过滤器中删除该key。通过expire key 0设置过期时间为0就可以实现删除
- 布隆过滤器存在误判
  - 现象：在集合中的元素判断为不在集合中。
  - 原因：这个是由于hash碰撞导致的，比如说A和B通过hash算法计算出相同的hash值，A不在数据库中，B在数据库中，如果A在集合中更新值为0，这时候查询B，得到的值为0，从而得到错误的结论。
  - 解决方案：对于每个元素使用不同hash算法，计算出多个hash值。只有所有hash值对应数组中的值都为1，那么才说明元素存在数据库中。
- 布隆过滤器不支持删除元素
  - 现象：删除元素导致误判
  - 原因：同样是因为hash碰撞。比如说A和B通过hash算法计算出相同的hash值，这时候把A删除了，那么把A的hash值对应的位置设置为0，那么查询B，则认为B不在数据库中了，从而得到错误的结论。
  - 解决方案：让数组不在存储0和1，而是存储一个计数，比如说A和B通过hash算法计算出相同的hash值，那么这个hash值对应数组的值为2，那么删除A之后，该位置的值为1，这时候查询B，还是认为元素是存在的。
    - 但是这个方案实际上也有缺陷，因为数组的元素不再是bit，而是整数，内存消耗就增大。





**前面说的都是预防的方案，万一真的发生缓存穿透，要怎么解决呢？**

比方说当有一个极热点的缓存项，它一旦失效会有大量请求穿透到数据库，这会对数据库造成瞬时极大的压力，我们把这个场景叫做“dog-pile effect”（狗桩效应），

这是典型的缓存并发穿透的问题，那么，我们如何来解决这个问题呢？解决狗桩效应的思路是尽量地减少缓存穿透后的并发，方案也比较简单：

1、在代码中控制在某一个热点缓存项失效之后启动一个后台线程，穿透到数据库，将数据加载到缓存中，在缓存未加载之前，所有访问这个缓存的请求都不再穿透而直接返回。

2、通过在 Memcached 或者 Redis 中设置分布式锁，只有获取到锁的请求才能够穿透到数据库。

分布式锁的方式也比较简单，比方说 ID 为 1 的用户是一个热点用户，当他的用户信息缓存失效后，我们需要从数据库中重新加载数据时，先向 Redis 中写入一个 Key 为"lock.1"的缓存项（后面的请求发现有这个key了，setnx失败，直接返回），然后去数据库里面加载数据，当数据加载完成后再把这个 Key 删掉。这时，如果另外一个线程也要请求这个用户的数据，它发现缓存中没有 Key 为“lock.1”的缓存，就认为目前已经有线程在加载数据库中的值到缓存中了，它就可以重新去缓存中查询数据，不再穿透数据库了。





## 缓存雪崩

### 概念

如果缓存集中在一段时间内失效，所有的查询都落在数据库上，数据库调用了暴增，造成数据库挂掉的情况，这就是缓存雪崩。

![image-20191109120302486](https://tva1.sinaimg.cn/large/006y8mN6gy1g8rnmml3eij310m0lcwnm.jpg)





### 解决方案

- 应用层限流，避免同一时间大量请求导致数据库压力暴增，服务不可用。
- 使用redis集群保证缓存层高可用
- 给缓存设置不同的过期时间，避免同一时间点大量缓存过期失效
- 数据预热，预先把热点数据存入缓存中
- 一致性hash（减少雪崩造成的影响）







## 参考

[缓存穿透和缓存雪崩](https://www.cnblogs.com/George1994/p/10668889.html)

[布隆过滤器解决缓存穿透](https://q.cnblogs.com/q/117521/)