# SnowFlake算法生成全局ID

可以使用SnowFlake算法做一个发号器（ID生成器），业务方请求发号器，发号器生成全局ID。



## 原理结构

snowflake算法所生成的ID结构是什么样子呢？我们来看看下图：

![image-20191113125945956](https://tva1.sinaimg.cn/large/006y8mN6gy1g8wbqxh6m9j30j106fgmy.jpg)

SnowFlake所生成的ID一共分成四部分：

- 第一位
  - 占用1bit，其值始终是0，没有实际作用。
- 时间戳
  - 占用41bit，精确到毫秒，总共可以容纳约69年的时间。对于一个系统来说足够了。
  - 如果系统存活时间快超过69年，还可以增加时间戳的位数（通过减少其他部分的位数）
- 工作机器id
  - 占用10bit，最多可以容纳1024个节点。
  - 这10位又可以拿出几位作为机房标识，几位作为该机房下节点标识
- 序列号
  - 占用12bit，这个值在 **同一毫秒** **同一节点** 上从0开始不断累加，最多可以累加到4095。



SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？只需要做一个简单的乘法：

**同一毫秒的ID数量 = 1024 X 4096 = 4194304**

这个数字在绝大多数并发场景下都是够用的。



## 优点

- ID呈趋势递增，后续插入索引树的时候性能较好。
- 全局唯一性
- 完全在内存生成，高性能



## 缺点

依赖于系统时间。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序。

如果我们发现系统时间不准，立即让发号器停止发好，直到系统时钟准确为止。



## 实现方式

- 嵌入到业务代码中
  - 嵌入到业务代码里，也就是分布在业务服务器中。这种方案的好处是业务代码在使用的时候不需要跨网络调用，性能上会好一些，但是就**需要更多的机器 ID 位数来支持更多的业务服务器**。另外，由于业务服务器的数量很多，**我们很难保证机器 ID 的唯一性，所以就需要引入 ZooKeeper 等分布式一致性组件来保证每次机器重启时都能获得唯一的机器 ID**。
- 作为独立的服务部署
  - 另外一个部署方式是作为独立的服务部署，这也就是我们常说的发号器服务。业务在使用发号器的时候就需要多一次的网络调用，但是内网的调用对于性能的损耗有限，却可以减少机器 ID 的位数，如果发号器以主备方式部署，同时运行的只有一个发号器，那么机器 ID 可以省略，这样可以留更多的位数给最后的自增信息位。即使需要机器 ID，因为发号器部署实例数有限，那么就可以把机器 ID 写在发号器的配置文件里，这样即可以保证机器 ID 唯一性，也无需引入第三方组件了。微博和美图都是使用独立服务的方式来部署发号器的。



### 代码实现

简单说下伪代码的实现：

一个生成全局ID的请求过来，雪花算法首先第一位是0，表示整个数字是一个整数，然后使用毫秒填充接下来41位，然后使用当前机器ID填充接来下10位。

最后再判断一下，这台机器上这一毫秒内，这是第几个请求，给这次生成 id 的请求累加一个序号，作为最后的 12 个 位。

到此，一个全局性自增id就完成了。





## 问题

**如果请求发号器的 QPS 不高，比如说发号器每毫秒只发一个 ID，就会造成生成 ID 的末位永远是 1，那么在分库分表时如果使用 ID 作为分区键就会造成库表分配的不均匀，有什么优化方法？**

- 时间戳不记录毫秒而是记录秒，这样在一个时间区间里可以多发出几个号，避免出现分库分表时数据分配不均。
- 生成的序列号的起始号可以做一下随机，这一秒是 21，下一秒是 30，这样就会尽量的均衡了。



## 参考

[SnowFlake算法生成全局ID](https://blog.csdn.net/bjweimengshu/article/details/80162731)

[雪花算法的Java实现](https://blog.csdn.net/lq18050010830/article/details/89845790)

