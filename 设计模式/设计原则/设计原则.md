**找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起**

把会变化的代码抽离并且封装起来，以后可以轻易改动这部分代码，而不会影响不需要变化的代码。



**针对接口编程，而不是针对实现编程**

- 主要是可以利用到多态
  - 运行时才指定具体实现的对象（比如是@Resource注入），从而执行该对象的具体实现方法。

- 在运行时通过改变具体实现对象，从而改变执行的动作



**多用组合，少用继承**

组合的弹性更好，也可以达到运行时通过改变对象从而改变行为的目的。



**交互对象之间，应该松耦合**

松耦合能让对象之间的依赖降到最低，从而让系统更有弹性。



**类应该对扩展开发，对修改关闭**



**依赖倒置原则**

要依赖抽象，不要依赖具体类



依赖倒置，倒置在哪？ 

 在依赖倒置原则中的倒置指的是和一般的OO设计的思考方式完全相反。如果说设计一个比萨店，我们应该从上往下思考，先要有一个比萨店，然后比萨点根据要求生产出具体类型的比萨。 

现在倒置你的想法，从下往上思考，把比萨抽象出来，让比萨店、比萨具体实现 都依赖于比萨的抽象接口，从而解耦。(具体方式可以是简单工厂，也可以是工厂方法模式)



本来的设计方式：

![Snip20190519_5](https://ws1.sinaimg.cn/large/006tNc79gy1g36sonaiobj31300u0gz5.jpg)



依赖倒置的设计方式：

![Snip20190519_6](https://ws3.sinaimg.cn/large/006tNc79gy1g36so8a9l2j316o0t0wni.jpg)





**最少知识原则**

不要让太多类耦合在一起，免得修改系统的一部分，会影响到另外一部分。





**底层组件不要调用高层组件**

比如说有DAO、Manager两层，只能Manager调用DAO，而不能DAO调用Manager。不然会很混乱。





**单一职责**

类的每个职责都有改变的潜在区域，超过一个责任，意味潜在着改变的区域个数超过一个。一个类应该只有一个职责，从而只有一个引起变化的原因。



**内聚**

当来一个类或者一个模块被设计成只支持一组相关功能的时候，我们说它具有高内聚。反之，当被设计成支持一组不相关的功能时，我们说它具有低内聚。



**里氏替换原则**

在代码里面， 把父类替换成它的子类， 程序的行为不会有变化， 简单地说， 子类型必须能够替换掉它们的父类型。

也正因为这个原则， 使得继承复用成为了可能， **只有当子类可以替换掉父类， 程序的功能不受到影响时，父类才能真正被复用， 而子类也能够在父类的基础上增加新的行为。**

里氏替换原则为继承定义的规范：

- 子类必须完全实现父类的方法
- 子类可以有自己的新方法、新属性